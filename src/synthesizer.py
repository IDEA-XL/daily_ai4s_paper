import logging
from typing import List
from datetime import datetime
import asyncio
import aiofiles  # Import the async file I/O library
import os

from src.data_models import AnalyzedPaper, PaperCandidate

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class MarkdownSynthesizer:
    """
    Compiles the final daily report in Markdown format.
    This class is responsible for generating the content, but can also save it asynchronously.
    """

    def __init__(self, template: str = "default", report_saving_dir: str = "."):
        """
        Initializes the MarkdownSynthesizer.
        
        Args:
            template (str): The name of the template to use. Currently only 'default'.
            report_saving_dir (str): The directory where reports will be saved. Defaults to current directory.
        """
        self.template = template
        self.report_saving_dir = report_saving_dir

    def synthesize(self, analyzed_papers: List[AnalyzedPaper]) -> str:
        """
        Generates a Markdown report from a list of analyzed papers.
        This is a synchronous method that returns a string, containing no blocking I/O.

        Args:
            analyzed_papers (List[AnalyzedPaper]): The list of papers to include in the report.

        Returns:
            str: A single string containing the full Markdown content.
        """
        logging.info(f"Starting Markdown synthesis for {len(analyzed_papers)} papers.")
        
        if not analyzed_papers:
            logging.warning("No analyzed papers to synthesize. Returning empty report.")
            return "# AI4Science Daily Paper Report\n\nNo relevant papers found today."

        report_date = datetime.now().strftime("%Y-%m-%d")
        
        # --- Report Header ---
        markdown_content = [
            f"# AI4Science Daily Paper Report",
            f"**Date:** {report_date}",
            f"\n---\n"
            f"Today's top picks in AI for Science. We've analyzed {len(analyzed_papers)} papers to bring you the key insights."
            f"\n---\n"
        ]

        # --- Paper Entries ---
        for i, paper in enumerate(analyzed_papers, 1):
            paper_content = self._format_paper(paper, i)
            markdown_content.append(paper_content)

        # --- Report Footer ---
        markdown_content.append(
            "---\n"
            "Generated by the AI4Science Daily Paper Digestion Agent."
        )
        
        full_report = "\n\n".join(markdown_content)
        logging.info("Successfully synthesized Markdown report.")
        return full_report

    async def save_report_async(self, report_content: str, file_name: str) -> None:
        """
        Asynchronously saves the report content to a file within the specified report_saving_dir.
        This is the non-blocking way to write files.

        Args:
            report_content (str): The Markdown string to save.
            file_name (str): The name of the file to save the report as (e.g., "report.md").
        """
        file_path = os.path.join(self.report_saving_dir, file_name)
        try:
            # Ensure the directory exists
            os.makedirs(self.report_saving_dir, exist_ok=True)
            async with aiofiles.open(file_path, "w", encoding='utf-8') as f:
                await f.write(report_content)
            logging.info(f"Report successfully saved to {file_path}")
        except Exception as e:
            logging.error(f"Failed to save report to {file_path}: {e}")

    def _format_paper(self, paper: AnalyzedPaper, index: int) -> str:
        """
        Formats a single paper into a Markdown section. (No changes needed here)
        """
        meta = paper.metadata
        title_line = f"## {index}. {meta.title}"
        authors_line = f"**Authors:** *{', '.join(meta.authors)}*"
        source_line = f"**Source:** [{meta.source}]({meta.url}) | **PDF:** [Link]({meta.pdf_url})"
        links = []
        if paper.resource_links.get("github"):
            links.append(f"[GitHub]({paper.resource_links['github']})")
        if paper.resource_links.get("huggingface"):
            links.append(f"[Hugging Face]({paper.resource_links['huggingface']})")
        links_line = f"**Resources:** {' | '.join(links)}" if links else ""
        summary_section = f"### Summary\n{paper.summary}"
        keywords_section = f"**Keywords:** `{', '.join(paper.keywords)}`"
        qa_details = ""
        for q, a in paper.analysis_qa.items():
            qa_details += f"**Q:** {q}\n\n**A:** {a}\n\n"
        qa_section = (
            "<details>\n"
            "<summary><strong>Detailed Analysis (Q&A)</strong></summary>\n\n"
            f"{qa_details}"
            "</details>"
        )
        paper_parts = [
            title_line,
            authors_line,
            source_line,
            links_line,
            keywords_section,
            summary_section,
            qa_section
        ]
        return "\n\n".join(filter(None, paper_parts))


# The `if __name__ == '__main__':` block is for standalone testing.
# It's okay for it to be blocking because it's not running inside an async event loop.
# To test the new async function, we wrap it in `asyncio.run()`.
if __name__ == '__main__':
    # --- Example Usage for standalone testing ---
    
    dummy_candidate = PaperCandidate(
        id="12345", url="http://example.com/paper", pdf_url="http://example.com/paper.pdf",
        title="Example Paper on AI in Physics", abstract="This is an abstract.",
        authors=["John Doe", "Jane Smith"], source="arXiv"
    )
    
    dummy_analyzed_paper = AnalyzedPaper(
        metadata=dummy_candidate,
        keywords=["AI", "Physics", "Simulations"],
        analysis_qa={
            "What is the key innovation?": "A novel neural network architecture for simulating quantum systems.",
            "What are the limitations?": "The model is computationally expensive and has only been tested on small systems."
        },
        resource_links={"github": "http://github.com/example/repo"},
        summary="This paper introduces a new deep learning model that significantly improves the accuracy of quantum simulations..."
    )
    
    synthesizer = MarkdownSynthesizer(report_saving_dir="./temp_reports")
    markdown_report = synthesizer.synthesize([dummy_analyzed_paper, dummy_analyzed_paper])
    
    print("--- Generated Report Content ---")
    print(markdown_report)

    async def main_test():
        # Test the new async save function
        await synthesizer.save_report_async(markdown_report, "example_report.md")

    # Run the async test function
    asyncio.run(main_test())
    
    print("\n--- Example report saved to ./temp_reports/example_report.md using async save ---")